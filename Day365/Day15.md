# let 为什么可以解决循环陷阱

## 循环陷阱

循环陷阱就是看似每个新创建的函数都需要一个单独的变量，但是没有实现，所以叫做循环陷阱

### 例：

```JavaScript
const logs = [];
for(var i = 0 ; i < 4 ; i++) {
  logs[i] = ()=>{
    console.log(i)
  }
}
logs[2]() // 4
```

在上例中无论是哪一个 log 都会打印 4。

#### 解析

- logs 中的函数打印的值是其父作用域中的`i`形成了闭包。
- 因为 `i` 是 `var` 关键字定义的变量。其不会在块级作用域中定义，会提升到其更高的位置，即 全局作用域。
- 而 `log` 函数在调用时，其取值都是 全局作用域中的 `i` 值，即 `i` 的最终结果 4 。

### IIFE 解决

```JavaScript
const logs = [];
for(var i = 0 ; i < 4 ; i++) {
  (function(n){
    logs[i] = ()=>{
      console.log(n)
    }
  })(i)
}
logs[2]() // 2
```

#### 解析

上例中在 `for` 循环中增加了一层 `function` 这个 函数接收了一个 参数 `n` 将 每次循环的 `i` 变成了自执行函数中的私域变量。`logs` 中的函数访问的值是其父级作用域中的值，也就是 `IIFE` 函数中的值。

### let 解决

```JavaScript
const logs = [];
for(let i = 0 ; i < 4 ; i++) {
  logs[i] = ()=>{
    console.log(i)
  }
}
logs[2]() // 2
```

#### 解析

在上例中，仅仅将 `i` 的关键字 从 `var` 换成了 `let` 就可以避免循环陷阱。原因 `let` 定义的变量会在块级作用域中定义，没一个`for`循环代码块都是一个作用域。所以 `logs` 函数 访问的是其 父级 块作用域中的 值。且每一次的`for`都会创建一个 闭包。
